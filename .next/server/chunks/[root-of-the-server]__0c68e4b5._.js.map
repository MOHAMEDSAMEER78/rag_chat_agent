{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///Users/msameem/Dev/personal/sameer/rag_chat_agent/app/lib/vectorStore.ts"],"sourcesContent":["import { Chroma } from '@langchain/community/vectorstores/chroma';\nimport { GoogleGenerativeAIEmbeddings } from '@langchain/google-genai';\nimport { Document } from '@langchain/core/documents';\nimport { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';\nimport { ScrapeResult } from './scrapers/angelOneSupport';\nimport { PDFContent } from './pdf-processor';\n\n// Initialize embeddings model\nlet embeddings: GoogleGenerativeAIEmbeddings;\nlet vectorStore: Chroma | null = null;\nlet isVectorStoreAvailable = true;\n\n// Function to initialize the embeddings model\nexport function initializeEmbeddings(apiKey: string) {\n  embeddings = new GoogleGenerativeAIEmbeddings({\n    apiKey: apiKey,\n    model: 'embedding-001',\n  });\n}\n\n// Function to initialize the vector store\nexport async function initializeVectorStore() {\n  if (!embeddings) {\n    throw new Error('Embeddings model is not initialized');\n  }\n\n  try {\n    vectorStore = new Chroma(embeddings, {\n      collectionName: 'angel_one_support',\n      url: process.env.CHROMA_URL || 'http://localhost:8000',\n    });\n\n    // Test the connection by performing a small query\n    await vectorStore.similaritySearch(\"test connection\", 1);\n    isVectorStoreAvailable = true;\n    \n    return vectorStore;\n  } catch (error) {\n    console.error('Error initializing vector store:', error);\n    isVectorStoreAvailable = false;\n    vectorStore = null;\n    throw new Error('Failed to initialize vector store. Is Chroma running?');\n  }\n}\n\n// Function to get the vector store (creates it if it doesn't exist)\nexport async function getVectorStore() {\n  if (!isVectorStoreAvailable) {\n    // Try to reinitialize if previously marked as unavailable\n    try {\n      return await initializeVectorStore();\n    } catch (error) {\n      console.error('Vector store is still unavailable:', error);\n      throw error;\n    }\n  }\n  \n  if (!vectorStore) {\n    try {\n      await initializeVectorStore();\n    } catch (error) {\n      console.error('Failed to initialize vector store:', error);\n      throw error;\n    }\n  }\n  \n  return vectorStore;\n}\n\n// Function to process and store web scraped content\nexport async function processAndStoreWebContent(scrapeResults: ScrapeResult[]) {\n  try {\n    const store = await getVectorStore();\n    if (!store) {\n      console.error('Vector store is not available');\n      return 0;\n    }\n\n    // Create a text splitter to break content into chunks\n    const textSplitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000,\n      chunkOverlap: 200,\n    });\n\n    const documents: Document[] = [];\n\n    // Process each scraped content\n    for (const result of scrapeResults) {\n      if (!result.content) continue;\n\n      // Split the content into chunks\n      const textChunks = await textSplitter.splitText(result.content);\n\n      // Create a document for each chunk\n      for (const chunk of textChunks) {\n        documents.push(\n          new Document({\n            pageContent: chunk,\n            metadata: {\n              source: result.url,\n              title: result.title,\n              type: 'web',\n            },\n          })\n        );\n      }\n    }\n\n    console.log(`Storing ${documents.length} documents from web content`);\n\n    // Add documents to the vector store\n    if (documents.length > 0) {\n      await store.addDocuments(documents);\n    }\n\n    return documents.length;\n  } catch (error) {\n    console.error('Error processing web content:', error);\n    return 0;\n  }\n}\n\n// Function to process and store PDF content\nexport async function processAndStorePDFContent(pdfContents: PDFContent[]) {\n  try {\n    const store = await getVectorStore();\n    if (!store) {\n      console.error('Vector store is not available');\n      return 0;\n    }\n\n    // Create a text splitter to break content into chunks\n    const textSplitter = new RecursiveCharacterTextSplitter({\n      chunkSize: 1000,\n      chunkOverlap: 200,\n    });\n\n    const documents: Document[] = [];\n\n    // Process each PDF\n    for (const pdf of pdfContents) {\n      if (!pdf.content) continue;\n\n      // Split the content into chunks\n      const textChunks = await textSplitter.splitText(pdf.content);\n\n      // Create a document for each chunk\n      for (const chunk of textChunks) {\n        documents.push(\n          new Document({\n            pageContent: chunk,\n            metadata: {\n              source: pdf.filename,\n              type: 'pdf',\n            },\n          })\n        );\n      }\n    }\n\n    console.log(`Storing ${documents.length} documents from PDF content`);\n\n    // Add documents to the vector store\n    if (documents.length > 0) {\n      await store.addDocuments(documents);\n    }\n\n    return documents.length;\n  } catch (error) {\n    console.error('Error processing PDF content:', error);\n    return 0;\n  }\n}\n\n// Function to query the vector store\nexport async function queryVectorStore(query: string, k: number = 5) {\n  try {\n    const store = await getVectorStore();\n    if (!store) {\n      console.error('Vector store is not available');\n      return [];\n    }\n\n    // Perform similarity search\n    const results = await store.similaritySearch(query, k);\n    return results;\n  } catch (error) {\n    console.error('Error querying vector store:', error);\n    isVectorStoreAvailable = false; // Mark as unavailable for future calls\n    return [];\n  }\n} "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"sources":["file:///Users/msameem/Dev/personal/sameer/rag_chat_agent/app/lib/chatModel.ts"],"sourcesContent":["import { ChatGoogleGenerativeAI } from '@langchain/google-genai';\nimport { StringOutputParser } from '@langchain/core/output_parsers';\nimport { Document } from '@langchain/core/documents';\nimport { \n  ChatPromptTemplate, \n  HumanMessagePromptTemplate, \n  SystemMessagePromptTemplate\n} from '@langchain/core/prompts';\nimport { RunnableSequence } from '@langchain/core/runnables';\nimport { queryVectorStore } from './vectorStore';\n\nlet model: ChatGoogleGenerativeAI;\n\n// Initialize the chat model\nexport function initializeChatModel(apiKey: string) {\n  model = new ChatGoogleGenerativeAI({\n    apiKey: apiKey,\n    model: 'gemini-1.5-pro',\n    temperature: 0.2,\n  });\n}\n\n// Create a formatter function for retrieved documents\nfunction formatDocumentsAsChatContext(documents: Document[]): string {\n  return documents.map((doc, i) => {\n    const source = doc.metadata.source || 'Unknown source';\n    return `Document ${i + 1} (Source: ${source})\\n${doc.pageContent}\\n`;\n  }).join('\\n\\n');\n}\n\n// Function to check if a query is within the support scope\nexport async function isWithinSupportScope(query: string): Promise<boolean> {\n  try {\n    // Attempt to retrieve relevant documents \n    const results = await queryVectorStore(query, 3);\n    \n    // If we found ANY relevant documents, consider it in scope\n    return results.length > 0;\n  } catch (error) {\n    console.error('Error checking support scope:', error);\n    // If there's an error accessing the vector store, return false\n    return false;\n  }\n}\n\n// Generate a response using RAG\nexport async function generateResponse(query: string): Promise<string> {\n  // Check if the model is initialized\n  if (!model) {\n    throw new Error('Chat model is not initialized');\n  }\n\n  try {\n    // First, check if the query is within the support scope\n    const inScope = await isWithinSupportScope(query);\n\n    if (!inScope) {\n      // If no relevant documents, or vector store is not available\n      if (model) {\n        // Use the model to generate a fallback response without RAG\n        return await generateBasicResponse(query);\n      } else {\n        return \"I don't know. Also, the knowledge base is not available.\";\n      }\n    }\n\n    // Retrieve relevant documents\n    const documents = await queryVectorStore(query, 5);\n    \n    // Format the documents as context\n    const context = formatDocumentsAsChatContext(documents);\n\n    // Create a system prompt that instructs the model to only use provided information\n    const systemTemplate = \n      `You are a helpful customer support agent for Angel One, a financial services company.\n      Answer the user's question based ONLY on the information provided in the context below.\n      If the answer cannot be determined from the context, respond with \"I don't know.\"\n      Do not make up or infer information that is not explicitly stated in the context.\n      \n      Context:\n      {context}`;\n\n    // Create a prompt template\n    const chatPrompt = ChatPromptTemplate.fromMessages([\n      SystemMessagePromptTemplate.fromTemplate(systemTemplate),\n      HumanMessagePromptTemplate.fromTemplate('{query}')\n    ]);\n\n    // Create a chain\n    const chain = RunnableSequence.from([\n      {\n        query: (input: { query: string }) => input.query,\n        context: (input: { query: string }) => context\n      },\n      chatPrompt,\n      model,\n      new StringOutputParser()\n    ]);\n\n    // Run the chain\n    const response = await chain.invoke({\n      query: query\n    });\n\n    return response;\n  } catch (error) {\n    console.error('Error generating response:', error);\n    return \"I'm having trouble accessing my knowledge base. Please try again later.\";\n  }\n}\n\n// Fallback function when vector store is not available\nasync function generateBasicResponse(query: string): Promise<string> {\n  try {\n    const systemTemplate = \n      `You are a helpful customer support agent for Angel One, a financial services company.\n      Answer the user's question to the best of your ability.\n      If you don't know the answer, respond with \"I don't know.\"\n      State that the knowledge base is currently unavailable, but you'll try to help with general information.`;\n\n    const chatPrompt = ChatPromptTemplate.fromMessages([\n      SystemMessagePromptTemplate.fromTemplate(systemTemplate),\n      HumanMessagePromptTemplate.fromTemplate('{query}')\n    ]);\n\n    const chain = RunnableSequence.from([\n      {\n        query: (input: { query: string }) => input.query\n      },\n      chatPrompt,\n      model,\n      new StringOutputParser()\n    ]);\n\n    const response = await chain.invoke({\n      query: query\n    });\n\n    return response;\n  } catch (error) {\n    console.error('Error generating fallback response:', error);\n    return \"I'm having trouble right now. Please try again later.\";\n  }\n} "],"names":[],"mappings":";;;;;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAKA;AAAA;AACA;;;;;;AAEA,IAAI;AAGG,SAAS,oBAAoB,MAAc;IAChD,QAAQ,IAAI,uKAAA,CAAA,yBAAsB,CAAC;QACjC,QAAQ;QACR,OAAO;QACP,aAAa;IACf;AACF;AAEA,sDAAsD;AACtD,SAAS,6BAA6B,SAAqB;IACzD,OAAO,UAAU,GAAG,CAAC,CAAC,KAAK;QACzB,MAAM,SAAS,IAAI,QAAQ,CAAC,MAAM,IAAI;QACtC,OAAO,CAAC,SAAS,EAAE,IAAI,EAAE,UAAU,EAAE,OAAO,GAAG,EAAE,IAAI,WAAW,CAAC,EAAE,CAAC;IACtE,GAAG,IAAI,CAAC;AACV;AAGO,eAAe,qBAAqB,KAAa;IACtD,IAAI;QACF,0CAA0C;QAC1C,MAAM,UAAU,MAAM,CAAA,GAAA,2HAAA,CAAA,mBAAgB,AAAD,EAAE,OAAO;QAE9C,2DAA2D;QAC3D,OAAO,QAAQ,MAAM,GAAG;IAC1B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,+DAA+D;QAC/D,OAAO;IACT;AACF;AAGO,eAAe,iBAAiB,KAAa;IAClD,oCAAoC;IACpC,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI;QACF,wDAAwD;QACxD,MAAM,UAAU,MAAM,qBAAqB;QAE3C,IAAI,CAAC,SAAS;YACZ,6DAA6D;YAC7D,IAAI,OAAO;gBACT,4DAA4D;gBAC5D,OAAO,MAAM,sBAAsB;YACrC,OAAO;gBACL,OAAO;YACT;QACF;QAEA,8BAA8B;QAC9B,MAAM,YAAY,MAAM,CAAA,GAAA,2HAAA,CAAA,mBAAgB,AAAD,EAAE,OAAO;QAEhD,kCAAkC;QAClC,MAAM,UAAU,6BAA6B;QAE7C,mFAAmF;QACnF,MAAM,iBACJ,CAAC;;;;;;eAMQ,CAAC;QAEZ,2BAA2B;QAC3B,MAAM,aAAa,gKAAA,CAAA,qBAAkB,CAAC,YAAY,CAAC;YACjD,gKAAA,CAAA,8BAA2B,CAAC,YAAY,CAAC;YACzC,gKAAA,CAAA,6BAA0B,CAAC,YAAY,CAAC;SACzC;QAED,iBAAiB;QACjB,MAAM,QAAQ,kKAAA,CAAA,mBAAgB,CAAC,IAAI,CAAC;YAClC;gBACE,OAAO,CAAC,QAA6B,MAAM,KAAK;gBAChD,SAAS,CAAC,QAA6B;YACzC;YACA;YACA;YACA,IAAI,yKAAA,CAAA,qBAAkB;SACvB;QAED,gBAAgB;QAChB,MAAM,WAAW,MAAM,MAAM,MAAM,CAAC;YAClC,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,8BAA8B;QAC5C,OAAO;IACT;AACF;AAEA,uDAAuD;AACvD,eAAe,sBAAsB,KAAa;IAChD,IAAI;QACF,MAAM,iBACJ,CAAC;;;8GAGuG,CAAC;QAE3G,MAAM,aAAa,gKAAA,CAAA,qBAAkB,CAAC,YAAY,CAAC;YACjD,gKAAA,CAAA,8BAA2B,CAAC,YAAY,CAAC;YACzC,gKAAA,CAAA,6BAA0B,CAAC,YAAY,CAAC;SACzC;QAED,MAAM,QAAQ,kKAAA,CAAA,mBAAgB,CAAC,IAAI,CAAC;YAClC;gBACE,OAAO,CAAC,QAA6B,MAAM,KAAK;YAClD;YACA;YACA;YACA,IAAI,yKAAA,CAAA,qBAAkB;SACvB;QAED,MAAM,WAAW,MAAM,MAAM,MAAM,CAAC;YAClC,OAAO;QACT;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 383, "column": 0}, "map": {"version":3,"sources":["file:///Users/msameem/Dev/personal/sameer/rag_chat_agent/app/api/chat/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { generateResponse, initializeChatModel } from '@/app/lib/chatModel';\nimport { initializeEmbeddings } from '@/app/lib/vectorStore';\n\n// Initialize the models with API key from environment variables\nif (process.env.GOOGLE_API_KEY) {\n  initializeChatModel(process.env.GOOGLE_API_KEY);\n  initializeEmbeddings(process.env.GOOGLE_API_KEY);\n}\n\nexport async function POST(req: NextRequest) {\n  try {\n    // Check for Google API key\n    if (!process.env.GOOGLE_API_KEY) {\n      return NextResponse.json(\n        { error: 'Google API key is not configured' },\n        { status: 500 }\n      );\n    }\n\n    // Parse the request body\n    const body = await req.json();\n    const { messages } = body;\n\n    if (!messages || !Array.isArray(messages) || messages.length === 0) {\n      return NextResponse.json(\n        { error: 'Messages array is required' },\n        { status: 400 }\n      );\n    }\n\n    // Extract the latest user message\n    const latestMessage = messages[messages.length - 1];\n    \n    if (latestMessage.role !== 'user') {\n      return NextResponse.json(\n        { error: 'Last message must be from user' },\n        { status: 400 }\n      );\n    }\n\n    // Generate a response\n    const response = await generateResponse(latestMessage.content);\n\n    // Return the response\n    return NextResponse.json({\n      role: 'assistant',\n      content: response\n    });\n  } catch (error) {\n    console.error('Error processing chat request:', error);\n    return NextResponse.json(\n      { error: 'An error occurred while generating the response' },\n      { status: 500 }\n    );\n  }\n} "],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AAEA,gEAAgE;AAChE,IAAI,QAAQ,GAAG,CAAC,cAAc,EAAE;IAC9B,CAAA,GAAA,yHAAA,CAAA,sBAAmB,AAAD,EAAE,QAAQ,GAAG,CAAC,cAAc;IAC9C,CAAA,GAAA,2HAAA,CAAA,uBAAoB,AAAD,EAAE,QAAQ,GAAG,CAAC,cAAc;AACjD;AAEO,eAAe,KAAK,GAAgB;IACzC,IAAI;QACF,2BAA2B;QAC3B,IAAI,CAAC,QAAQ,GAAG,CAAC,cAAc,EAAE;YAC/B,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmC,GAC5C;gBAAE,QAAQ;YAAI;QAElB;QAEA,yBAAyB;QACzB,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,EAAE,QAAQ,EAAE,GAAG;QAErB,IAAI,CAAC,YAAY,CAAC,MAAM,OAAO,CAAC,aAAa,SAAS,MAAM,KAAK,GAAG;YAClE,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA6B,GACtC;gBAAE,QAAQ;YAAI;QAElB;QAEA,kCAAkC;QAClC,MAAM,gBAAgB,QAAQ,CAAC,SAAS,MAAM,GAAG,EAAE;QAEnD,IAAI,cAAc,IAAI,KAAK,QAAQ;YACjC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAiC,GAC1C;gBAAE,QAAQ;YAAI;QAElB;QAEA,sBAAsB;QACtB,MAAM,WAAW,MAAM,CAAA,GAAA,yHAAA,CAAA,mBAAgB,AAAD,EAAE,cAAc,OAAO;QAE7D,sBAAsB;QACtB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YACvB,MAAM;YACN,SAAS;QACX;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAkD,GAC3D;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}